# x86汇编导论(1) 

这篇导论讲述了32位x86汇编语言的基础，涵盖了可用指令和汇编程序指令小而精的一部分。实际上有几种不同的汇编语言可用于生成x86机器代码，但是在CS216中，我们将会使用MASM(Microsoft Macro Assembler)汇编器。MSAM使用了标准的intel语法编写x86汇编代码。

## 资源

- [Guide to Using Assembly in Visual Studio](http://www.cs.virginia.edu/~evans/cs216/guides/vsasm.html) - 在VS中构建和调试程序集代码的教程
- [Intel x86 Instruction Set Reference](http://www.felixcloutier.com/x86/)
- [Intel's Pentium Manuals](http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html)

## 寄存器

现代x86处理器有8个32位通用寄存器，如Figure 1所示。这些寄存器的命名大多都具有历史原因。例如`EAX`寄存器叫做累加器因为它以前被许多算术计算使用，还有`ECX`被称为计数器因为它被用来存储循环索引。尽管大多数的寄存器在现在的指令集中已经不在具有特殊的意义，但是仍然有两个寄存器有着专门的用途，栈寄存器(stack pointer)ESP，以及基址寄存器(base pointer)EBP。

对于`EAX`,`EBX`,`ECX`,`EDX`四个寄存器，我们通常会将他们的一部分当做一个独立寄存器，例如，EAX的最低2个有效字节可以当做一个16位寄存器`AX`，`AX`的最低有效字节又可以当做一个8位寄存器叫做`AL`,高有效字节作为8位寄存器叫做`AH`，这几个不同的名称指代的是用一个物理寄存器，当一个2`bytes`大小的指令被放入`DX`,整个`EDX`，包括`DH`,`DL`的值都会改变，这些子寄存器主要是为了兼容以前的16位版本的指令集。然而，有时候在处理小于32位(eg： 1个字节的ASCII字符)时，它们更加的方便。

当我们使用汇编语言引用寄存器的时候，名称不区分大小写。例如，名字`EAX`和`eax`是指代同一个寄存器。

![Figure 1](http://www.cs.virginia.edu/~evans/cs216/guides/x86-registers.png)

<center>Figure 1</center>

## 内存和寻址模式

### 声明静态数据区域

在x86汇编中，你可以通过使用特殊汇编指令专门地声明静态数据区域(类似于全局变量)。数据声明应该紧跟着`.DATA`指令，在这个指令之后，指令`DB`,`DW`以及`DD`分别可以被用来声明1个,2个,4个字节的数据内存，被声明的位置可以用名称标记以供之后的引用，这类似于按名称声明变量，但是它遵循着一些比较低级别的规则。例如，按顺序声明的空间将在内存中彼此相邻的位置。

一个数据定义的例子:

```assembly
.DATA			
var		DB 64  		; 声明一个单字节变量，叫做var，存放数据64
var2	DB ?	; 声明一个未初始化单字节变量, 叫做var2
DB 		10			; 声明一个没有标签的单字节变量, 存放数据10，它的地址是 var2 + 1
X		DW ?		; 声明一个两字节未初始化变量，叫做x
Y		DD 30000    ; 声明一个四字节变量，叫做y，初始化为30000
```

不同于高级语言中数组可以有多个维度，可以通过索引值访问，在x86汇编语言中的数组是一些在内存中连续存放的简单单元格。只需要列出数组的值就可以声明数组，如下面第一个例子所示。还有其他两个用于声明数组的方法

是使用`DUP`指令，以及使用字符串文字。`DUP`指令告诉汇编器将表达式重复指定的次数，例如,`4 DUP(2)`等同于`2, 2, 2, 2`。

一些例子:

```assembly
Z	DD 1, 2, 3			; 声明3个4字节变量，初始化位1, 2, 3 z + 8 的值为 3
bytes  	DB 10 DUP(?)	; 从位置字节开始声明10个未初始化的字节
arr	DD 100 DUP(0)    	; 从位置arr开始声明100个四字节变量，都初始化为0
str	DB 'hello',0		; 从地址str开始声明6个字节，并初始化为ASCII字符值hello和空（0）字节
```

### 寻址模式

现代的x86寄存器在内存中能够寻址的地址多达$2^{32}$字节:内存地址是32位宽，在上面我们使用标签指代内存区域的例子中，这些标签实际上被汇编器以一个32位的内存地址所代替。除了支持通过标签引用存储区域(i.e. constant values)， x86 还提供了一种用于计算和引用内存地址的灵活方案:最多可以将两个32位寄存器和一个32位带符号的常量加在一起计算存储器地址。单个寄存可可以选择预乘2,4或者8。

寻址模式可以与许多其他x86指令一起使用(接下来的部分会讲到).在这里，我们距离说明一些使用`mov`指令在寄存器和内存中移动数据的示例。这个指令有两个操作数:第一个是目的，第二个是源。

一些`mov`指令寻址的例子如下:

```assembly
mov eax, [ebx]			; 将ebx中包含的地址处的内存中的4个字节移动到eax中
mov [var], ebx			; 将ebx中的内容移动到内存地址var的4个字节中。(var是一个32位常量)
mov eax, [esi-4]		; 将内存地址ESI-4四个字节移入eax
mov [esi+eax], cl		; 将cl的地址移入 esi + eax 的地址中去
mov edx, [esi+4*ebx]    ; 将地址ESI + 4 * EBX的4字节数据移到EDX
```

非法的示例如下:

```assembly
mov eax, [ebx-ecx]	;寄存器的值只能使用加法
mov [eax+esi+edi], ebx    	; 地址计算中最多使用两个寄存器
```

### 指令大小

一般情况下，数据项被分配的内存大小可以从引用该数据项的汇编代码指令中推断出来。例如，在以上的所有指令中，我们可以从寄存器操作数的大小推断出存储区域的大小。当我们加载一个32位的寄存器的时候，汇编器可能会推断出我们所指的内存区域为4个字节宽。当我们将1个字节大小的寄存器的值存入内存中的时候，汇编程序可以推断出我们希望该地址引用内存中的1个字节。

但是，在某些情况下，引用的存储区域的大小是不确定的，例如指令`mov [ebx], 2`这个指令是否是将值2移入到地址为`ebx`的单个字节中？或许他应该是将2的32位整数表示形式移到从地址`ebx`开始的4个字节。由于任何一种解释都是有效可行的，汇编器必须明确的知道哪一种是正确的。大小指令`BYTE PTR`,`WORD PTR`,以及`DWORD PTR`正是用来指定值的大小，他们分别指示1, 2, 4个字节的大小。

 eg：

```assembly
mov BYTE PTR [ebx], 2	; 将2移动到ebx中存储的地址中，以单字节存储
mov WORD PTR [ebx], 2	; 将2的16位整数表示形式移动到从ebx中地址开始的2个字节
mov DWORD PTR [ebx], 2  ; 将2的32位整数表示形式移动到从ebx中地址开始的4个字节
```

