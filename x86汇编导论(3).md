# x86汇编导论(3) 

## 调用约定

为了允许不同的程序员共享代码并开发供其他程序使用的库，并简化子程序的使用。程序员通常采取一个通用的**调用约定**。调用约定是一个有关如何调用子程序并从子程序中返回的协议。例如，给定一组调用约定规则，程序员无需检查子程序的定义去确定如何将参数传递给子程序。此外，给定一组调用约定规则，高级语言也可以使用成遵循这些规则的编译器，从而允许手动编码的汇编语言程序和高级语言程序之间相互调用。

实际上，许多的调用约定都是可能的。我们将会使用广泛使用的C语言调用约定。遵循此约定，将允许我们编写可以从C&C++代码中安全调用汇编子程序的代码，还能使得我们从汇编语言中调用C库语言。

C调用约定在很大程度上基于硬件支持的堆栈的使用。它基于`push`,`pop`,`call`,`ret`指令。子程序参数在栈中传递。寄存器保存在栈中，子程序使用的局部变量也放在内存的栈中。在大多数处理器上是想的绝大多数高级过程语言都使用了类似的调用约定。

调用约定分为两组规则。第一组规则由子程序的调用者使用，第二组规则被子程序的编写者(被调用者)使用。应当强调的是，如果在遵循这些规则时出现了错误会迅速导致致命的程序错误，因为栈的状态将会处于一个不一致的状态；因此在自己的子程序中实现调用约定的时候应该格外的小心。

![img](http://www.cs.virginia.edu/~evans/cs216/guides/stack-convention.png)

<center>Stack during Subroutine Call</center>

可视化调用约定操作的好方法是在子程序执行过程中绘制栈附近区域的内容。上图描述了在执行带有三个参数和三个局部变量的子程序期间栈上的内容。栈中描述的单元是32位宽的内存位置，因此，单元的存储位置相隔4个字节。第一个参数与基本指针的偏移量为8个字节。调用约定在栈中参数的上方(在EBP的下方)，`call`指令放置了返回地址，从而导致从EBP到第一个参数的偏移量增加了额外的4个字节。当使用`ret`指令从子程序中返回时，它将跳转到存储在栈中的返回地址。

### Caller Rules

要进行一个子程序调用，调用者应该知道:

1. 在调用子程序之前，调用者应该保存`caller-saved`寄存器的内容。`caller-saved`寄存器包括:`EAX`,`EBX`,`ECX`,`EDX`。因为允许被调用的子程序修改这些寄存器的内容，如果子程序返回之后调用者依赖于它们的值，调用者必须将这些寄存器中的值入栈(以便于在子程序返回之后将其恢复)。
2. 要将参数传递给子程序，请在子程序被调用之前将参数压入栈中。应当按相反的顺序入栈(即最后一个参数最先入栈)。由于栈向下扩张，因此第一个参数将存储在最低位置(参数的翻转曾经被用来允许函数传递可变数量的参数)
3. 要调用一个子程序，请使用`call`指令。这个指令将返回地址放在栈的顶部，并跳转到子程序代码。这将调用子程序，子程序应当遵循以下的被调用者规则。

在子程序返回后(紧随着调用指令之后)，调用者应当能在EAX中找到该子程序返回地址的值。要恢复机器状态，调用者应该:

1. 从栈中释放参数。这会将栈恢复到执行调用之前的状态。
2. 将`caller-saved`寄存器的值从栈中弹出恢复。

例子:

下面的代码展示了一个遵循调用者规则的函数调用。调用者正在调用带有三个整数参数的函数`_myFunc`。第一个参数是`EAX`，第二个参数是常数，第三个参数在内存`var`中。

```assembly
push [var] ; Push last parameter first
push 216   ; Push the second parameter
push eax   ; Push first parameter last

call _myFunc ; Call the function (assume C naming)

add esp, 12
```

请注意，在调用返回之后，调用者使用了add指令清理堆栈。我们在栈上有12 bytes大小的空间(3个参数，每一个4 bytes),栈是向下扩展，因此要清除参数，我们可以简单地将12加到`SP`上

`_myFunc`产生的结果现在寄存器`EAX`中使用，调用者保存的寄存器（ECX和EDX）的值可能已更改。如果调用者在调用之后会使用它们，则需要在调用之前将它们保存在栈中，并在调用之后将其恢复。

### Callee Rules

在子程序开始的时候，子程序的定义应该遵循以下的规定；

1. 将`EBP`入栈，然后使用以下的指令将`ESP`的值赋给`EBP`：

    ```assembly
    push ebp
    mov	 ebp, esp
    ```

    初始操作将保存`EBP`。根据惯例，基址指针被用来当做在栈上查找参数和局部变量的参考点。当子程序执行时，基址指针保存该子程序开始执行时的栈指针副本值，参数和局部变量将始终位于距基本指针值已知的恒定偏移量处。我们将旧的基址指针在子程序的初始化位置入栈以便于在子程序返回的时候可以为调用者恢复基址指针。谨记调用者不希望子程序改变基址指针的值。之后我们将栈指针移入`ESP`，用于获得访问参数和局部变量的参考值。

2. 然后，在栈上分配内存用于存放局部变量。再重复一遍，栈向下扩展，因此为了在栈上分配空间，`SP`指针应该减小。`SP`该减少多少取决于所需的局部变量的数量和大小。例如，如果有3个整数类型的局部变量(每一个4字节)，那么`sp`指针需要减12来为这几个变量分配空间(`sub esp, 12`).与参数一样，局部变量位于距离`BP`指针已知常量的偏移处。

3. 接下来，保存接下来将会使用的`callee-saved`寄存器的值。为了保存寄存器的值，将他们入栈。`callee-saved`寄存器包括:`EBX`,`EDI`,`ESI`(`ESP`和`EBP`也将通过调用约定保留，但是在这个步骤中不需要将他们入栈)

在执行了上面个的三个动作之后，子程序的主体程序开始执行，在子程序返回的时候，它们必须遵循以下的约定:

1. 将返回值存放在`EAX`中。
2. 通过从栈上弹出寄存器来恢复所有已修改的`callee-saved`寄存器(`EDI` & `ESI`)的值。寄存器的值应该按照入栈的顺序逆序弹出。
3. 释放局部变量已分配内存。最明显的方法可能是将`SP`指针加上合适的值(因为我们是通过将`sp`指针减去适当的值来分配内存的)。实际上在释放内存时错误率较小的方法是将基址指针中的值移入栈指针`move esp, ebp`。这之所以可行是因为基址指针始终保存在分配局部变量之前的栈指针的值。
4. 在返回之前，通过从栈中弹出`EBP`来活肤调用者的`BP`的值。回想一下，我们在进入子程序的时候所做的第一件事情就是讲基址指针入栈保存它原来的值。
5. 最后，通过执行`ret`指令返回到调用者函数。这个指令将从栈中查找然后删除正确的返回地址。

请注意，被调用者规则被分为了两部分，但是实际上他们是彼此的镜像。规则的第一部分适用于函数的开头。通常被定义为方法的 *prologue*。第二部分适用于函数的结尾，因此通常被称为函数的 *epilogue*

例子:

这里是一个遵循被调用者规则的示例函数:

```assembly
.486
.MODEL FLAT
.CODE
PUBLIC _myFunc
_myFunc PROC
  ; Subroutine Prologue
  push ebp     ; Save the old base pointer value.
  mov ebp, esp ; Set the new base pointer value.
  sub esp, 4   ; Make room for one 4-byte local variable.
  push edi     ; Save the values of registers that the function
  push esi     ; will modify. This function uses EDI and ESI.
  ; (no need to save EBX, EBP, or ESP)

  ; Subroutine Body
  mov eax, [ebp+8]   ; Move value of parameter 1 into EAX
  mov esi, [ebp+12]  ; Move value of parameter 2 into ESI
  mov edi, [ebp+16]  ; Move value of parameter 3 into EDI

  mov [ebp-4], edi   ; Move EDI into the local variable
  add [ebp-4], esi   ; Add ESI into the local variable
  add eax, [ebp-4]   ; Add the contents of the local variable
                     ; into EAX (final result)

  ; Subroutine Epilogue 
  pop esi      ; Recover register values
  pop  edi
  mov esp, ebp ; Deallocate local variables
  pop ebp ; Restore the caller's base pointer value
  ret
_myFunc ENDP
END
```

子程序的序言执行标准动作将栈指针的"快照"保存在`EBP`中，通过减小栈指针位局部变量分配内存，然后将寄存器的值保存在栈上。

在子程序的主体程序中，我们可以看到`ESP`的使用。在子程序执行的过程中，参数和局部变量都和基址指针保持了恒定的偏移量。实际上，我们可以观察到，由于参数实在调用子程序之前就入栈，因此他们在栈中始终位于基址指针的下方(即位于一个较高的地址)。子程序的第一个参数始终可以在内存位置`ESP + 8` 中找到，第二个参数可以在`EBP + 16` 中找到，第三个参数可以在`EBP + 16`中找到。同样，由于局部变量是在基址指针入栈之后才分配空间，因此他们在栈中始终位于基址指针的上方。实际上，第一个变量始终位于`EBP - 4`的位置，第二个局部变量始终位于`EBP - 8` 的位置，依次类推。基址指针的这种常规使用方法使得我们可以快速识别函数体内部的局部变量和参数的使用。

程序尾声基本而上是函数序言的一个镜像。从栈中恢复调用者寄存器的值，然后通过重置栈指针来释放局部变量，调用者的基址指针恢复，最后`ret`指令被用来返回到调用者函数的适当位置处。

## 参考

[原文 :x86 Assembly Guide](http://www.cs.virginia.edu/~evans/cs216/guides/x86.html#instructions)

