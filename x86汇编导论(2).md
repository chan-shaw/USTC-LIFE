# x86汇编导论(2)

## 指令集

机器指令通常可以分为三类：数据移动，算术/逻辑运算，控制流。在这部分中，我们将会研究每一个类别中重要的x86指令的示例。本节中不会详细的讨论整个x86的详尽指令，只会讨论一个有用的子集。有关的完整列表，请参阅英特尔指令集参考。

我们将会使用以下符号:

```assembly
<reg32>    	任意的32位的寄存器 (EAX, EBX, ECX, EDX, ESI, EDI, ESP, or EBP)
<reg16>		任意的16位寄存器 (AX, BX, CX, or DX)
<reg8>		任意的8位寄存器 (AH, BH, CH, DH, AL, BL, CL, or DL)
<reg>		任意寄存器
<mem>		一个内存地址 (e.g., [eax], [var + 4], or dword ptr [eax+ebx])
<con32>		任意32位常量
<con16>		任意16位常量
<con8>		任意8位常量
<con>		任意8,18,32位常量
```

### 数据移动指令

#### mov - Move(opcodes:88, 89,8A,8B,8C,8E,...)

`mov`指令将其第二个操作数所引用的数据项(即寄存器内容，寄存器内容或者常数值)复制到第一个操作数所引用的位置(一个寄存器或者内存地址)。虽然可以进行寄存器到寄存器之间的移动，但是不能直接从内存到内存的移动。如果需要在内存中传输内容，必须先将源存储器的内容加载到寄存器中，然后才能将其存储到目标存储器的地址中。

语法:

```assembly
mov <reg>,<reg>
mov <reg>,<mem>
mov <mem>,<reg>
mov <reg>,<const>
mov <mem>,<const>
```

例子:

```assembly
mov eax, ebx 			— copy the value in ebx into eax
mov byte ptr [var], 5 	— store the value 5 into the byte at location var
```

#### push - push stack(Opcodes:FF,89,8A,8B,8C,8E,...)

`push`指令将其操作数放置在内存中受硬件支持的栈顶部。具体而言，`push`指令首先将`ESP`递减4，然后将其操作数放在`[esp]`所指代的地址中。因为x86的栈是向下增长的-即从高地址到低地址，因此ESP`(栈指针)递减。

语法:

```assembly
push <reg32>
push <mem>
push <con32>
```

例子:

```assembly
push eax 	— push eax on the stack
push [var] 	— push the 4 bytes at address var onto the stack
```

#### pop - pop stack

`pop`指令将4字节的数据元素从栈的顶部移除并移动到指定的位置中(寄存器或者内存)，它首先将位于存储器位置`[sp]`的4个字节移动到指定的就成年期或者存储器位置，然后`sp`递增4。

语法:

```assembly
pop <reg32>
pop <mem>
```

例子:

```assembly
pop edi 	— pop the top element of the stack into EDI.
pop [ebx] 	— pop the top element of the stack into memory at the four bytes starting at location EBX.
```

#### lea - load effective address

`lea`指令将第二个操作数指定的地址放入第一个操作数指定的寄存器。值得注意的是，我们不会加载内存地址中的**内容**,仅仅计算有效地址并将它放入寄存器。这对于获得指向存储区域的指针很有用。

语法:

```assembly
lea <reg32>,<mem>
```

例子:

```assembly
lea edi, [ebx+4*esi] 	— the quantity EBX+4*ESI is placed in EDI.
lea eax, [var] 			— the value in var is placed in EAX.
lea eax, [val] 			— the value val is placed in EAX.
```

### 算术和逻辑指令

#### add - Integer Addition

加法指令将两个操作数相加，并将结果存在第一个操作数里。注意，尽管两个操作数都可以是寄存器，但是最多只允许一个操作数是内存。

语法:

```assembly
add <reg>,<reg>
add <reg>,<mem>
add <mem>,<reg>
add <reg>,<con>
add <mem>,<con>
```

例子:

```assembly
add eax, 10 			— EAX ← EAX + 10
add BYTE PTR [var], 10 	— add 10 to the single byte stored at memory address var
```

#### sub - Integer Subtraction

`sub`指令将第一个操作数减去第二个操作数，并将结果存储在第一个操作数中，与加法类似

语法:

```assembly
sub <reg>,<reg>
sub <reg>,<mem>
sub <mem>,<reg>
sub <reg>,<con>
sub <mem>,<con>
```

例子:

```assembly
sub al, ah 		— AL ← AL - AH
sub eax, 216 	— subtract 216 from the value stored in EAX
```

#### inc,dec - Increment, Decrement

`inc`指令令其操作数内容 + 1。dec指令将其操作数的内容 - 1。

语法:

```assembly
inc <reg>
inc <mem>
dec <reg>
dec <mem>
```

例子:

```assembly
dec eax				 — subtract one from the contents of EAX.
inc DWORD PTR [var]  — add one to the 32-bit integer stored at location var
```

#### imul - Integer Multiplication

`imul`指令具有两种基本格式: 二操作数(语法中上面的两个)和三操作数(语法中的下面两个)

二操作数形式将两个操作数相乘并将结果存储在第一个操作数中。结果（即第一个）操作数必须是一个寄存器。

三操作数形式将其第二和第三操作数相乘，并将结果存储在第一个操作数中。同样，结果操作数必须是一个寄存器。此外第三个操作数应该是一个常量。

语法:

```assembly
imul <reg32>,<reg32>
imul <reg32>,<mem>
imul <reg32>,<reg32>,<con>
imul <reg32>,<mem>,<con>
```

例子:

```assembly
imul eax, [var] — multiply the contents of EAX by the 32-bit contents of the memory 						location var. Store the result in EAX.
imul esi, edi, 25 — ESI → EDI * 25
```

#### idiv - Integer Division

`idiv`指令将64位整数`EDX:EAX`的内容除以指定的操作数(通过将EDX视为最高有效4个字节，将EAX视为最低有效4个字节来构造)。除法的商存储在`EAX`中，余数存储在`EDX`中。

语法:

```assembly
idiv <reg32>
idiv <mem>
```

例子:

```assembly
idiv ebx 				— divide the contents of EDX:EAX by the contents of EBX. Place 								the quotient in EAX and the remainder in EDX.
idiv DWORD PTR [var] 	— divide the contents of EDX:EAX by the 32-bit value stored at 								memory location var. Place the quotient in EAX and the 									remainder in EDX.
```

#### and, or, xor - Bitwise logical and, or and exclusive or

这些指令在其操作数上执行指定的逻辑运算(分别是逻辑按位和，或以及异或)，并将结果存放在第一个操作数。

语法:

```assembly
and <reg>,<reg>
and <reg>,<mem>
and <mem>,<reg>
and <reg>,<con>
and <mem>,<con>
or <reg>,<reg>
or <reg>,<mem>
or <mem>,<reg>
or <reg>,<con>
or <mem>,<con>
xor <reg>,<reg>
xor <reg>,<mem>
xor <mem>,<reg>
xor <reg>,<con>
xor <mem>,<con>
```

例子:

```assembly
and eax, 0fH — clear all but the last 4 bits of EAX.
xor edx, edx — set the contents of EDX to zero.
```

#### not - Bitwise Logical Not

逻辑取反操作数的内容(即翻转操作数中的所有位值)

语法:

```assembly
not <reg>
not <mem>
```

例子:

```assembly
not BYTE PTR [var] — negate all bits in the byte at the memory location var.
```

#### neg - Negate

执行操作数内容的二进制补码求反

语法:

```assembly
neg <reg>
neg <mem>
```

例子:

```assembly
neg eax  — EAX → - EAX
```

#### shl,shr - Shift Left, Shift Right

这些指令左右移动第一个操作数的内容中的比特值，并用零填充结果的空位位置。移位之后的操作数最多可以移位31位。要移动的位数由第二个操作数指定，可以是8位常数或者是寄存器`CL`。在任何情况下，如果数字大于31的话，将其模32再运算。

语法:

```assembly
shl <reg>,<con8>
shl <mem>,<con8>
shl <reg>,<cl>
shl <mem>,<cl>

shr <reg>,<con8>
shr <mem>,<con8>
shr <reg>,<cl>
shr <mem>,<cl>
```

例子:

```assembly
shl eax, 1 	— Multiply the value of EAX by 2 (if the most significant bit is 0)
shr ebx, cl — Store in EBX the floor of result of dividing the value of EBX by 2n wheren is the value in CL.
```

### 控制流指令

x86处理器维护一个指令指针寄存器(IP,instruction pointer)该寄存器是一个32位的值，指示当前指令在内存中的位置。通常来说，它递增以指向内存中当前执行指令之后的下一条指令。IP寄存器被不能直接操作，而应该通过提供的控制流指令隐式操作。

我们通过使用符号`<label>`来引用程序文本中带有标签的位置。通过输入的标签名称和冒号，可以将标签插入x86汇编代码文本中的任何位置。例如:

```assembly
       mov esi, [ebp+8]
begin: xor ecx, ecx
       mov eax, [esi]
```

该代码段中第二条指令标记为`begin`，在代码的其他地方，我们可以使用更方便的名称`begin`来引用此指令在内存中的存储位置。标签仅仅是一个方便的方式用来替代一个32位的地址值。

#### jmp - jump

将程序控制流转移到操作数指示的存储位置处的指令。

语法:

```assembly
jmp <label>
```

例子:

```assembly
jmp begin — Jump to the instruction labeled begin.
```

#### jcondition - Conditional Jump

这些指令是基于一组条件代码的状态的条件跳转，这些条件代码被存储在一个被称为机器状态字的特殊寄存器中。机器状态字的内容是有关最后执行的算术运算的信息。例如，该字的最后一位指示结果是否为0，另一个指示最后结果是否为负数。基于这些条件代码，可以执行许多条件跳转。例如，如果最后一次算术运算结果为0，那么`jz`指令将会跳转到指定的操作数标签。偶尔控制顺序进行到下一条指令。

许多条件分支的名称都根据上次执行的操作直观地给出，这个操作就是比较指令`cmp`(参考下文)，例如，条件分支（例如`jle`和`jne`）基于首先对所需操作数执行`cmp`操作。

语法:

```assembly
je <label> (jump when equal)
jne <label> (jump when not equal)
jz <label> (jump when last result was zero)
jg <label> (jump when greater than)
jge <label> (jump when greater than or equal to)
jl <label> (jump when less than)
jle <label> (jump when less than or equal to)
```

例子:

```assembly
cmp eax, ebx
jle done
```

如果`EAX`的内容小于或者等于`EBX`的内容，就跳转到完整标签，否则继续下一条指令。

#### cmp - Compare

比较两个指定操作数的值，在机器状态字中适当地设置条件代码。该指令除里将计算结果丢弃而未存入第一个操作数之外，等同于`sub`指令。

语法:

```assembly
cmp <reg>,<reg>
cmp <reg>,<mem>
cmp <mem>,<reg>
cmp <reg>,<con>
```

例子:

```assembly
cmp DWORD PTR [var], 10
jeq loop
```

如果存储在位置var的4个字节等于4个字节的整数常量10，则跳转到标记为loop的位置。

#### call, ret - Subroutine call and return

这些程序实现了子程序的调用和返回。首先`call`指令将当前代码位置压栈，然后无条件跳转到标签操作数指示的代码位置。不同于简单的跳转指令，`call`指令回保存子程序完成后的返回地址。

`ret`指令实现了子程序返回的机制。该指令首先从栈中弹出代码位置，然后它无条件跳转到检索到的代码的位置。

语法:

```assembly
call <label>
ret
```

